"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var express_session_1 = require("express-session");
var etcd3_1 = require("etcd3");
var debug_1 = require("debug");
/**
 * One day in seconds.
 */
exports.oneDay = 86400;
/**
 * Max TTL time to leasing on ETCD3 Client in seconds.
 */
exports.maxTTL = 6442450;
/**
 * Default configuration values for the etcd v3 options
 */
exports.defaultOptions = Object.freeze({
    prefix: 'sess',
    hosts: '127.0.0.1:2379',
    skipTouch: false
});
/**
 * An etcd v3 store adapter for Express session using [etcd3](https://github.com/mixer/etcd3) client.
 *
 * ```
 * var session = require('express-session');
 * var Etcd3Store = require('express-session-etcd3');
 *
 * app.use(session({
 *     store: new Etcd3Store(options),
 *     secret: 'keyboard cat',
 *     resave: false
 * }));
 * ```
 */
var Etcd3Store = /** @class */ (function (_super) {
    __extends(Etcd3Store, _super);
    function Etcd3Store(config, client) {
        if (config === void 0) { config = exports.defaultOptions; }
        if (client === void 0) { client = new etcd3_1.Etcd3(config); }
        var _this = _super.call(this, config) || this;
        _this.config = config;
        _this.client = client;
        _this.debug = debug_1.default('express-session:etcd3');
        /**
         * This method is used to get a session from the store given a session
         * ID (`sid`). The `callback` should be called as `callback(error, session)`.
         *
         * The `session` argument should be a session if found, otherwise `null` or
         * `undefined` if the session was not found (and there was no error). A special
         * case is made when `error.code === 'ENOENT'` to act like `callback(null, null)`.
         */
        _this.get = function (sid, callback) {
            _this.debug('GET "%s"', sid);
            try {
                _this.client
                    .get(_this.key(sid))
                    .json()
                    .then(function (val) { return _this.callbackWithLog(callback, null, val); }, function (err) { return _this.callbackWithLog(callback, err); });
            }
            catch (err) {
                _this.callbackWithLog(callback, err);
            }
        };
        /**
         * This required method is used to upsert a session into the store given a
         * session ID (`sid`) and session (`session`) object. The callback should be
         * called as `callback(error)` once the session has been set in the store.
         */
        _this.set = function (sid, session, callback) {
            var ttl = _this.getTTL(session, sid);
            _this.debug('SET "%s" ttl:%s %O', sid, ttl, session);
            try {
                var leasing_1 = _this.client.lease(ttl);
                leasing_1
                    .put(_this.key(sid))
                    .value(JSON.stringify(session))
                    .then(function () {
                    leasing_1.release();
                    _this.callbackWithLog(callback);
                }, function (err) { return _this.callbackWithLog(callback, err); });
            }
            catch (err) {
                callback(err);
            }
        };
        /**
         * This method is used to "touch" a given session given a
         * session ID (`sid`) and session (`session`) object. The `callback` should be
         * called as `callback(error)` once the session has been touched.
         *
         * This is primarily used when the store will automatically delete idle sessions
         * and this method is used to signal to the store the given session is active,
         * potentially resetting the idle timer.
         */
        _this.touch = function (sid, session, callback) {
            if (_this.config.skipTouch) {
                _this.debug('SKIP TOUCH "%s"', sid);
                callback(null);
                return;
            }
            _this.debug('TOUCH "%s" %O', sid, session);
            _this.set(sid, session, callback);
        };
        /**
         * This method is used to get all sessions in the store as an array. The
         * `callback` should be called as `callback(error, sessions)`.
         */
        _this.all = function (callback) {
            _this.debug('ALL');
            try {
                _this.client
                    .getAll()
                    .prefix(_this.key())
                    .json()
                    .then(function (json) { return Object.values(json); })
                    .then(function (val) { return _this.callbackWithLog(callback, null, val); }, function (err) { return _this.callbackWithLog(callback, err); });
            }
            catch (err) {
                _this.callbackWithLog(callback, err);
            }
        };
        /**
         * This method is used to get the count of all sessions in the store.
         * The `callback` should be called as `callback(error, len)`.
         */
        _this.length = function (callback) {
            _this.debug('LENGTH');
            try {
                _this.client
                    .getAll()
                    .prefix(_this.key())
                    .count()
                    .then(function (val) { return _this.callbackWithLog(callback, null, val); }, function (err) { return _this.callbackWithLog(callback, err); });
            }
            catch (err) {
                _this.callbackWithLog(callback, err);
            }
        };
        /**
         * This method is used to destroy/delete a session from the store given
         * a session ID (`sid`). The `callback` should be called as `callback(error)`
         * once the session is destroyed.
         */
        _this.destroy = function (sid, callback) {
            _this.debug('DESTROY');
            try {
                _this.client
                    .delete()
                    .prefix(_this.key(sid))
                    .then(function () { return _this.callbackWithLog(callback); }, function (err) { return _this.callbackWithLog(callback, err); });
            }
            catch (err) {
                callback(err);
            }
        };
        /**
         * This method is used to delete all sessions from the store. The `callback`
         * should be called as `callback(error)` once the store is cleared.
         */
        _this.clear = function (callback) {
            _this.debug('CLEAR');
            try {
                _this.client
                    .delete()
                    .prefix(_this.key())
                    .then(function () { return _this.callbackWithLog(callback); }, function (err) { return _this.callbackWithLog(callback, err); });
            }
            catch (err) {
                _this.callbackWithLog(callback, err);
            }
        };
        _this.debug('init config: %O', config);
        return _this;
    }
    /**
     * Build the etcd key with the right prefix and the givin session ID (`sid`)
     */
    Etcd3Store.prototype.key = function (sid) {
        if (sid === void 0) { sid = ''; }
        return (this.config.prefix || exports.defaultOptions.prefix) + '/' + sid;
    };
    /**
     * Get the Time to Live (`ttl`) of the session
     */
    Etcd3Store.prototype.getTTL = function (sess, sid) {
        var rawTTL = this.getRawTTL(sess, sid);
        return rawTTL > exports.maxTTL ? exports.maxTTL : rawTTL;
    };
    /**
     * Get the raw Time to Live (`ttl`) of the session from the data sources
     */
    Etcd3Store.prototype.getRawTTL = function (sess, sid) {
        var storeTtl = this['ttl'];
        if (typeof storeTtl === 'number')
            return storeTtl;
        if (typeof storeTtl === 'string')
            return Number(storeTtl);
        if (typeof storeTtl === 'function')
            return storeTtl(this, sess, sid);
        if (storeTtl)
            throw new TypeError('`store.ttl` must be a number or function.');
        var maxAge = sess.cookie.maxAge;
        return typeof maxAge === 'number' ? Math.floor(maxAge / 1000) : exports.oneDay;
    };
    /**
     * Logging callback result
     */
    Etcd3Store.prototype.callbackWithLog = function (cb, err, value) {
        if (err === void 0) { err = null; }
        if (value === void 0) { value = null; }
        var log = err ? ['ERR %O', err] : value ? ['DONE, data: %O', value] : ['DONE'];
        this.debug.apply(this, [log.shift()].concat(log));
        cb(err, value);
    };
    return Etcd3Store;
}(express_session_1.Store));
exports.default = Etcd3Store;
//# sourceMappingURL=express-session-etcd3.js.map